/*
 * Copyright (C) 2021 Ilya Usanov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.b3er.kmapper.mapping.mappers

import com.github.b3er.kmapper.mapping.api.MappingContext
import com.github.b3er.kmapper.mapping.common.MappingElement
import com.github.b3er.kmapper.mapping.mappings.MappingFactory
import com.github.b3er.kmapper.mapping.mappings.PureMapping
import com.github.b3er.kmapper.mapping.utils.addOriginatingKSFile
import com.github.b3er.kmapper.mapping.utils.kModifiers
import com.github.b3er.kmapper.mapping.utils.toAnnotationSpec
import com.github.b3er.kmapper.mapping.utils.toClassName
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.*
import com.github.b3er.kmapper.Mapper as MapperClassAnnotation

class GeneratedMapper(declaration: KSClassDeclaration, context: MappingContext) : BaseMapper(declaration, context) {
    private val createdMappings = mutableListOf<PureMapping>()
    override fun allMappings(): Sequence<PureMapping> = declaredMappings.asSequence() + createdMappings.asSequence()

    override fun createMapping(
        target: MappingElement,
        source: MappingElement,
        parent: PureMapping
    ): PureMapping {
        return MappingFactory.createGeneratedMapping(this, target, source).also {
            createdMappings.add(it)
        }
    }

    override fun write(): FileSpec {
        val fileSpec = FileSpec.builder(implementationClassName.packageName, implementationClassName.simpleName)
            .addComment("Code generated by KMapper. Do not edit.")
        annotation.imports?.map { it.toClassName() }?.forEach { import ->
            fileSpec.addImport(import.packageName, import.simpleName)
        }
        val typeSpec = TypeSpec.classBuilder(implementationClassName)

        typeSpec.addOriginatingKSFile(declaration.containingFile!!)

        if (declaration.classKind == ClassKind.INTERFACE) {
            typeSpec.addSuperinterface(className)
        } else {
            typeSpec.superclass(className)
        }

        typeSpec.addModifiers(declaration.modifiers.kModifiers().filterNot { it == KModifier.ABSTRACT })

        typeSpec.addAnnotations(declaration.annotations.filter {
            it.annotationType != annotation.annotation.annotationType
        }.map { it.toAnnotationSpec(context.resolver) }.toList())

        val constSpec = FunSpec.constructorBuilder()
        if (annotation.injectionType == MapperClassAnnotation.InjectionType.Jsr330) {
            logger.info("Using JSR303 injection", declaration)
            constSpec.addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("javax.inject.Inject")).build())
        }
        includes.forEach { (mapper, name) ->
            constSpec.addParameter(name, mapper.declaration.toClassName())
            typeSpec.addProperty(
                PropertySpec
                    .builder(name, mapper.declaration.toClassName(), KModifier.PRIVATE)
                    .initializer(name).build()
            )
        }
        typeSpec.primaryConstructor(constSpec.build())
        declaredMappings.filter { !it.isImplemented }
            .forEach { mapper -> mapper.write().also { typeSpec.addFunction(it) } }
        val created = createdMappings.toList()
        created
            .forEach { mapper ->
                mapper.write().also { typeSpec.addFunction(it) }
            }
        typeSpec.writeCreatedMappings()
        fileSpec.addType(typeSpec.build())
        return fileSpec.build()
    }

    fun TypeSpec.Builder.writeCreatedMappings() {
        //TODO: Rewrite!
        while (createdMappings.any { !it.isImplemented }) {
            createdMappings.filterNot { it.isImplemented }.forEach { mapping ->
                mapping.write().also { addFunction(it) }
            }
        }
    }
}

