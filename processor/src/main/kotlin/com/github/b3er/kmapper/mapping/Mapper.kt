/*
 * Copyright (C) 2021 Ilya Usanov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.b3er.kmapper.mapping

import com.github.b3er.kmapper.mapping.api.MappingContext
import com.github.b3er.kmapper.mapping.common.MapperAnnotation
import com.github.b3er.kmapper.mapping.common.MappingElement
import com.github.b3er.kmapper.mapping.mappings.GeneratedMapping
import com.github.b3er.kmapper.mapping.mappings.MappingFactory
import com.github.b3er.kmapper.mapping.mappings.PureMapping
import com.github.b3er.kmapper.mapping.utils.*
import com.google.devtools.ksp.getDeclaredFunctions
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.*
import java.util.*
import com.github.b3er.kmapper.Mapper as MapperClassAnnotation

class Mapper(val declaration: KSClassDeclaration, val context: MappingContext) {
    val className by lazy { declaration.toClassName() }
    val implementationClassName by lazy { ClassName(className.packageName, className.simpleName + "Impl") }
    private val declaredMappins: List<PureMapping> by lazy {
        declaration.getDeclaredFunctions().map { dec ->
            MappingFactory.createMapping(context, this, dec)
        }.toList()
    }
    private val createdMappings = mutableListOf<PureMapping>()
    val annotation by lazy { declaration.getAnnotation<MapperClassAnnotation>()!!.let(::MapperAnnotation) }
    val logger = context.logger

    val includes by lazy {
        annotation.includes?.asSequence()
            ?.map(context::findMapper)
            ?.associate {
                it to it.declaration.simpleName.getShortName()
                    .replaceFirstChar { c -> c.lowercase(Locale.ROOT) }
            } ?: emptyMap()
    }

    fun allMappings(): Sequence<PureMapping> = declaredMappins.asSequence() + createdMappings.asSequence()

    fun findMapping(
        target: MappingElement,
        source: MappingElement,
        parent: PureMapping,
        createIfNeeded: Boolean
    ): PureMapping? {
        return allMappings().find { mapping ->
            target.isAssignableFrom(mapping.target) && mapping.isSourceCompatibleWith(source, parent.sources)
        } ?: includes.mapNotNull { (include, _) -> include.findMapping(target, source, parent, false) }
            .firstOrNull { it !is GeneratedMapping }
        ?: if (createIfNeeded) createMapping(target, source, parent) else null
    }

    fun createMapping(
        target: MappingElement,
        source: MappingElement,
        parent: PureMapping
    ): PureMapping {
        return MappingFactory.createGeneratedMapping(this, target, source).also {
            createdMappings.add(it)
        }
    }


    fun write(): FileSpec {
        val fileSpec = FileSpec.builder(implementationClassName.packageName, implementationClassName.simpleName)
            .addComment("Code generated by KMapper. Do not edit.")
        annotation.imports?.map { it.toClassName() }?.forEach { import ->
            fileSpec.addImport(import.packageName, import.simpleName)
        }
        val typeSpec = TypeSpec.classBuilder(implementationClassName)

        typeSpec.addOriginatingKSFile(declaration.containingFile!!)
        includes.forEach { (mapper, _) ->
            typeSpec.addOriginatingKSFile(mapper.declaration.containingFile!!)
        }
//        context
//            .mappers()
//            .filter { mapper -> mapper.includes[this] != null }
//            .forEach { mapper -> typeSpec.addOriginatingKSFile(mapper.declaration.containingFile!!) }

        typeSpec.addSuperinterface(className)

        typeSpec.addModifiers(declaration.modifiers.kModifiers())

        typeSpec.addAnnotations(declaration.annotations.filter {
            it.annotationType != annotation.annotation.annotationType
        }.map { it.toAnnotationSpec(context.resolver) }.toList())

        val constSpec = FunSpec.constructorBuilder()
        if (annotation.injectionType == MapperClassAnnotation.InjectionType.Jsr330) {
            logger.info("Using JSR303 injection", declaration)
            constSpec.addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("javax.inject.Inject")).build())
        }
        includes.forEach { (mapper, name) ->
            constSpec.addParameter(name, mapper.declaration.toClassName())
            typeSpec.addProperty(
                PropertySpec
                    .builder(name, mapper.declaration.toClassName(), KModifier.PRIVATE)
                    .initializer(name).build()
            )
        }
        typeSpec.primaryConstructor(constSpec.build())
        declaredMappins.filter { !it.isImplemented }
            .forEach { mapper -> mapper.write().also { typeSpec.addFunction(it) } }
        val created = createdMappings.toList()
        created
            .forEach { mapper ->
                mapper.write().also { typeSpec.addFunction(it) }
            }
        typeSpec.writeCreatedMappings()
        fileSpec.addType(typeSpec.build())
        return fileSpec.build()
    }

    fun TypeSpec.Builder.writeCreatedMappings() {
        //TODO: Rewrite!
        while (createdMappings.any { !it.isImplemented }) {
            createdMappings.filterNot { it.isImplemented }.forEach { mapping ->
                mapping.write().also { addFunction(it) }
            }
        }
    }

    fun toFullString(): String {
        return className.toString()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Mapper

        if (declaration != other.declaration) return false

        return true
    }

    override fun hashCode(): Int {
        return declaration.hashCode()
    }
}

