/*
 * Copyright (C) 2021 Ilya Usanov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.b3er.kmapper.mapping

import com.github.b3er.kmapper.mapping.api.MappingContext
import com.github.b3er.kmapper.mapping.api.MappingPropertyElement
import com.github.b3er.kmapper.mapping.common.MapperAnnotation
import com.github.b3er.kmapper.mapping.common.MappingTargetProperty
import com.github.b3er.kmapper.mapping.mappings.MappingFactory
import com.github.b3er.kmapper.mapping.mappings.PureMapping
import com.github.b3er.kmapper.mapping.utils.getAnnotation
import com.github.b3er.kmapper.mapping.utils.kModifiers
import com.github.b3er.kmapper.mapping.utils.toAnnotationSpec
import com.github.b3er.kmapper.mapping.utils.toClassName
import com.google.devtools.ksp.getDeclaredFunctions
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.*
import java.util.*
import com.github.b3er.kmapper.Mapper as MapperClassAnnotation

class Mapper(val declaration: KSClassDeclaration, val context: MappingContext) {
    val className by lazy { declaration.toClassName() }
    val implementationClassName by lazy { ClassName(className.packageName, className.simpleName + "Impl") }
    private val declaredMappins: List<PureMapping> by lazy {
        declaration.getDeclaredFunctions().map { dec ->
            MappingFactory.createMapping(context, this, dec)
        }.toList()
    }
    private val createdMappings = mutableListOf<PureMapping>()
    private val annotation by lazy { declaration.getAnnotation<MapperClassAnnotation>()!!.let(::MapperAnnotation) }
    val logger = context.logger

    val includes by lazy {
        annotation.includes?.asSequence()
            ?.map(context::findMapper)
            ?.associate {
                it to it.declaration.simpleName.getShortName()
                    .replaceFirstChar { c -> c.lowercase(Locale.ROOT) }
            } ?: emptyMap()
    }

    fun allMappings(): Sequence<PureMapping> = declaredMappins.asSequence() + createdMappings.asSequence()

    fun findMapping(
        target: MappingTargetProperty,
        source: MappingPropertyElement,
        parent: PureMapping,
        createIfNeeded: Boolean
    ): PureMapping? {
        return allMappings().find { mapping ->
            mapping.target.matches(target) && mapping.isSourceCompatibleWith(source, parent.sources)
        } ?: includes.mapNotNull { (include, _) -> include.findMapping(target, source, parent, false) }.firstOrNull()
        ?: if (createIfNeeded) createMapping(target, source, parent) else null
    }

    fun createMapping(
        target: MappingTargetProperty,
        source: MappingPropertyElement,
        parent: PureMapping
    ): PureMapping {
        return MappingFactory.createGeneratedMapping(this, target, source).also {
            createdMappings.add(it)
        }
    }


    fun write(): FileSpec {
        val fileSpec = FileSpec.builder(implementationClassName.packageName, implementationClassName.simpleName)
            .addComment("Code generated by KMapper. Do not edit.")
        annotation.imports?.map { it.toClassName() }?.forEach { import ->
            fileSpec.addImport(import.packageName, import.simpleName)
        }
        val typeSpec = TypeSpec.classBuilder(implementationClassName)

        typeSpec.addSuperinterface(className)

        typeSpec.addModifiers(declaration.modifiers.kModifiers())

        typeSpec.addAnnotations(declaration.annotations.filter {
            it.annotationType != annotation.annotation.annotationType
        }.map { it.toAnnotationSpec(context.resolver) }.toList())

        val constSpec = FunSpec.constructorBuilder()
        if (annotation.injectionType == MapperClassAnnotation.InjectionType.Jsr330) {
            logger.info("Using JSR303 injection", declaration)
            constSpec.addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("javax.Inject")).build())
        }
        includes.forEach { (mapper, name) ->
            constSpec.addParameter(name, mapper.declaration.toClassName())
            typeSpec.addProperty(
                PropertySpec
                    .builder(name, mapper.declaration.toClassName(), KModifier.PRIVATE)
                    .initializer(name).build()
            )
        }
        typeSpec.primaryConstructor(constSpec.build())
        declaredMappins.filter { !it.isImplemented }
            .forEach { mapper -> mapper.write().also { typeSpec.addFunction(it) } }
        createdMappings.filter { !it.isImplemented }
            .forEach { mapper -> mapper.write().also { typeSpec.addFunction(it) } }
        fileSpec.addType(typeSpec.build())
        return fileSpec.build()
    }

    fun toFullString(): String {
        return className.toString()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Mapper

        if (declaration != other.declaration) return false

        return true
    }

    override fun hashCode(): Int {
        return declaration.hashCode()
    }
}

